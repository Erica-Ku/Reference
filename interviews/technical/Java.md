# Java
  - 자바의 특징
    - 객체지향 프로그래밍(OOP) 언어
    - 기본 자료형을 제외한 모든 요소들이 객체로 표현되고, 객체지향 개념의 특징인 캡슐화, 상속, 다형성이 잘 적용된 언어
    - 장점
      - JVM 위에서 동작하기 때문에 운영체제에 독립적
      - GC를 통한 자동적인 메모리 관리 가능
    - 단점
      - 실행속도가 상대적으로 느림
      - 다중 상속이나 타입에 엄격하고 제약이 많음

  - OOP
    - 실생활에서 쓰는 모든 것을 객체라 하며, 객체지향 프로그래밍은 프로그램 구현에 필요한 객체를 파악하고 상태와 행위를 가진 객체를 만들고 각각의 객체들의 역할이 무엇인지를 정의하여
    객체들 간의 상호작용을 통해 프로그램을 만드는 것
    - 기능이 아닌 객체가 중심이며 '누가 어떤 일을 할 것인가?'가 핵심
    - 특징: 캡슐화, 상속, 다형성, 추상화 등
    - 모듈 재사용으로 확장 및 유지보수가 용이함
        
  - JVM의 역할
    - 스택 기반으로 동작하며, Java Byte Code를 OS에 맞게 해석해주는 역할을 하며 GC를 통해 자동적인 메모리 관리를 해줌
      
  - 자바의 컴파일 과정
    - .java 파일 생성 -> build -> 자바 컴파일러의 javac 명령어로 바이트코드(.class) 생성 -> 클래스로더를 통해 JVM 메모리 내로 로드함 -> 실행엔진을 통해 기계어로 해석됨(각 운영체제에 맞는)

  - 자바에서 제공하는 원시 타입
    - 정수형: byte(1), short(2), int(4), long(8)
    - 실수형: float(4), double(8)
    - 문자형: char(2)
    - 논리형: boolean(1)

  - 오버로딩과 오버라이딩
    - 오버로딩: 매개변수의 개수나 타입을 다르게 하여 같은 이름의 메서드를 여러 개 정의하는 것
    - 오버라이딩: 상위 클래스에 있는 메서드를 하위 클래스에서 재정의하는 것

  - try-with-resources
    - try-catch-finally의 문제점을 보완하기 위해 나온 개념
    - try(...) 안에 자원 객체를 전달하면 try 블록이 끝나고 자동으로 자원을 해제해주는 기능

  - 불변 객체 설명 및 자바에서 대표적인 예시 제시
    - 객체 생성 이후 내부의 상태가 변하지 않는 객체
    - 자바에서는 필드가 원시 타입인 경우 final 키워드를 사용해 불변 객체를 만들 수 있음
    - 참조 타입일 경우 추가적인 작업 필요
      - 참조 타입은 대표적으로 객체/배열/리스트 등을 참조할 수 있음
      - 객체: 객체를 사용하는 필드의 참조 변수도 불변 객체로 변경해야 함
      - 배열: 배열을 받아 복사해서 저장하고, getter를 clone으로 반환하도록 함
      - 리스트: 배열과 마찬가지로 생성 시 새로운 리스트를 만들어 값을 복사하도록 해야함
      - 배열과 리스트는 내부를 복사하여 전달하는데 이를 방어적 복사라고 함
    - 불변 객체나 final을 사용하는 이유
      - Thread-Safe하여 병렬 프로그래밍에 유용하며 동기화를 고려할 필요없음
      - 실패 원자적인 메서드를 만들 수 있음
      - 부수효과를 피해 오류를 최소화 함
        - 부수효과: 변수의 값이 바뀌거나 객체의 필드 값을 설정하거나 예외나 오류가 발생하여 실행이 중단되는 현상
      - 메서드 호출 시 파라미터 값이 변하지 않는다는 것을 보장함
      - GC 성능을 높일 수 있음

  - 추상 클래스와 인터페이스
    - 추상 클래스: 클래스 내 추상 메서드가 하나 이상 포함되거나 abstract로 정의된 경우를 말함
    - 인터페이스: 모든 메서드가 추상 메서드로만 이루어져 있는 것을 말함
    - 공통점
      - new 연산자로 인스턴스 생성 불가능
      - 사용하기 위해서 하위 클래스에서 확장/구현해야 함
    - 차이점
      - 인터페이스는 그 인터페이스를 구현하는 모든 클래스에 대해 특정한 메서드가 반드시 존재하도록 강제함
      - 추상클래스는 상속받는 클래스들의 공통적인 로직을 추상화시키고, 기능 확장을 위해 사용함
      - 추상클래스는 다중상속이 불가능하지만, 인터페이스는 다중구현이 가능함

  - 싱글톤 패턴
    - 단 하나의 인스턴스를 생성해 사용하는 디자인 패턴
    - 인스턴스가 1개만 존재해야 한다는 것을 보장하고 싶은 경우와 동일한 인스턴스를 자주 생성해야 하는 경우에 주로 사용함
    - 예시: 스프링 bean -> 스프링의 bean 등록 방식은 기본적으로 싱글톤 스코프이고, 스프링 컨테이너는 모든 bean들을 싱글톤으로 관리함

  - 가비지 컬렉션
    - JVM의 메모리 관리 기법 중 하나로 시스템에서 동적으로 할당됐던 메모리 영역 중에서 필요없어진 메모리 영역을 회수하여 메모리를 관리해주는 기법
    - 과정: JVM이 어플리케이션의 실행을 잠시 멈추고 GC를 실행하는 쓰레드를 제외한 모든 쓰레드들의 작업을 중단 후 사용하지 않는 메모리를 제거하고 작업이 재개됨

  - 객체지향 설계원칙
    - SRP(단일 책임 원칙): 한 클래스는 하나의 책임만 가져야 함
    - OCP(개방 폐쇄 원칙): 확장에는 열려있고 수정에는 닫혀있어야 함
    - LSP(리스코프 치환 원칙): 하위 타입은 항상 상위 타입을 대체할 수 있어야 함
    - ISP(인터페이스 분리 원칙): 인터페이스 내에 메서드는 최소한일수록 좋음
    - DIP(의존관계 역전 원칙): 구체적인 클래스보다 상위 클래스, 인터페이스, 추상클래스와 같이 변하지 않을 가능성이 높은 클래스와 관계를 맺음 -> 의존성 주입

  - 자바의 메모리 영역
    - 메서드 영역: 전역변수와 static변수를 저장하며, 메서드 영역은 프로그램의 시작부터 종료까지 메모리에 남아있음
    - 스택 영역
      - 지역변수와 매개변수 데이터 값이 저장되는 공간이며, 메서드가 호출될 때 메모리에 할당되고 종료되면 메모리가 해제됨
      - LIFO 구조를 갖고 변수에 새로운 데이터가 할당되면 이전 데이터는 지워짐
    - 힙 영역: new 키워드로 생성되는 객체(인스턴스), 배열 등이 힙 영역에 저장되며 가비지 컬렉션에 의해 메모리가 관리됨
    - 각 메모리 영역이 할당되는 시점
      - 메서드 영역: JVM이 동작해서 클래스가 로딩될 때 생성
      - 스택 영역: 컴파일 타임(소스코드가 기계어로 변환되어 실행가능한 프로그램이 되는 과정)시 할당
      - 힙 영역: 런타임(컴파일 타임 이후 프로그램이 실행되는 때)시 할당

  - 클래스와 객체
    - 클래스: 객체를 만들어내기 위한 설계도 혹은 틀이며 객체를 생성하는데 사용함
    - 객체: 클래스를 기반으로 생성되며 자신의 고유 이름과 상태(필드), 행동(메서드)을 가짐
    - 인스턴스: 객체에 메모리가 할당되어 실제로 활용되는 실체

  - 생성자
    - 생성자는 클래스와 같은 이름의 메서드로 객체가 생성될 때 호출됨
    - 명시적으로 생성자를 만들지 않아도 default로 만들어지며 생성자는 파라미터를 다르게 하여 오버로딩이 가능함

  - Wrapper 클래스, Boxing, UnBoxing
    - Wrapper 클래스: 기본 자료형에 대한 객체 표현
    - Boxing: 기본 자료형을 Wrapper 클래스로 변환하는 것
    - UnBoxing: Wrapper 클래스를 기본 자료형으로 변환하는 것

  - Synchronized
    - 여러 개의 쓰레드가 한 개의 자원을 사용하고자 할 때, 현재 데이터를 사용하고 있는 쓰레드를 제외하고 나머지 쓰레드들은 데이터에 접근할 수 없게 막는 개념
    - 데이터의 Thread-safe를 하기 위해 자바에서 Synchronized 키워드를 제공해 멀티 쓰레드 환경에서 쓰레드간 동기화를 시켜 데이터의 Thread-safe를 보장함
    - Synchronized는 변수와 메서드에 사용해서 동기화할 수 있으며, 이 키워드를 남발하게 되면 오히려 프로그램의 성능저하를 일으킬 수 있음

  - new String()과 리터럴("")의 차이
    - new String()은 new 키워드로 새로운 객체를 생성하기 때문에 힙 영역에 저장되고, ""은 힙 안에 있는 String Constant Pool 영역에 저장됨

  - String, StringBuffer, StringBuilder의 차이
    - String은 불변의 속성을 가지며, StringBuffer와 StringBuilder는 가변의 속성을 가짐
    - StringBuffer는 동기화를 지원하며 멀티 쓰레드 환경에서 주로 사용함
    - StringBuilder는 동기화를 지원하지 않아 싱글 쓰레드 환경에서 주로 사용함

  - 접근 제한자
    - 변수 또는 메서드의 접근 범위를 설정해주기 위해 사용하는 자바의 예약어
    - public: 접근 제한이 없음(같은 프로젝트 내 어디서든 사용 가능)
    - protected: 해당 패키지 내, 다른 패키지에서 상속받아 자손 클래스에서 접근이 가능함
    - default: 해당 패키지 내에서만 접근 가능
    - private: 해당 클래스에서만 접근 가능

  - 클래스 멤버 변수 초기화 순서
    - static 변수 선언부: 클래스가 로드될 때 변수가 제일 먼저 초기화됨
    - 필드 변수 선언부: 객체가 생성될 때 생성자 block보다 앞서 초기화됨
    - 생성자 block: 객체가 생성될 때 JVM이 내부적으로 locking(Thread-safe 영역)

  - static
    - static 키워드를 사용한 변수나 메서드는 클래스가 메모리에 올라갈 때 자동으로 생성되며 클래스 로딩이 끝나면 바로 사용할 수 있음 -> 인스턴스(객체) 생성 없이 바로 사용 가능
    - 모든 객체가 메모리를 공유한다는 특징이 있고 GC 관리 영역 밖에 있기 때문에 프로그램이 종료될 때까지 메모리 값이 유지된 채로 존재하게 됨
    - static을 사용하는 이유
      - 자주 변하지 않는 값이나 공통으로 사용되는 값 같은 공용자원에 대한 접근에 있어서 매번 메모리에 로딩하거나 값을 읽어들이는 것보다 일종의 전역변수와 같은 개념을 통해 접근하는 것이 비용도 줄이고 효율을 높일 수 있음
      - 인스턴스 생성 없이 바로 사용 가능하기 때문에 프로그램 내에서 공통으로 사용되는 데이터들을 관리할 때 이용함

  - 내부 클래스의 장점
    - 내부 클래스에서 외부 클래스의 멤버에 쉽게 접근할 수 있음
    - 서로 관련 있는 클래스를 논리적으로 묶어서 표현함으로써 캡슐화를 증가시키고 코드의 복잡성을 낮출 수 있음
    - 외부에서는 내부 클래스에 접근할 수 없으므로 코드의 보안성을 높일 수 있음

  - 리플렉션
    - 구체적인 클래스 타입을 알지 못해도 그 클래스의 메서드, 타입, 변수들에 접근할 수 있도록 해주는 자바 API
    - 어떤 경우에 사용?
      - 코드를 작성할 시점에는 어떤 타입의 클래스를 사용할지 모르지만 런타임 시점에 지금 실행되고 있는 클래스를 가져와서 실행해야 하는 경우
      - 프레임워크나 IDE에서 이런 동적인 바인딩을 이용한 기능을 제공함 -> 인텔리제이의 자동완성 기능, 스프링의 어노테이션이 리플렉션을 이용한 기능임

  - Error와 Exception의 차이
    - Error: 실행 중 일어날 수 있는 치명적 오류를 말하며 컴파일 시점에 체크할 수 없고 오류가 발생하면 프로그램은 비정상 종료되며 예측 불가능한 UnCheckedException에 속함
    - Exception: Error보다 비교적 경미한 오류이며 try-catch를 이용해 프로그램의 비정상 종료를 막을 수 있음

  - CheckedException, UnCheckedException의 차이
    - CheckedException: 실행하기 전에 예측 가능한 예외를 말하며 반드시 예외 처리를 해야함
    - UnCheckedException: 실행하고 난 후에 알 수 있는 예외를 말하며 따로 예외 처리를 하지 않아도 됨
    - RuntimeException은 UnCheckedException을 상속한 클래스이고, RuntimeException이 아닌 것은 CheckedException을 상속한 클래스임

  - Optional API 
    
